/*
 * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH
 * under one or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information regarding copyright
 * ownership. Camunda licenses this file to you under the Apache License,
 * Version 2.0; you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
 * CarbonAware.WebApi
 * This class uses the Carbon Aware SDK: https://github.com/Green-Software-Foundation/carbon-aware-sdk
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package de.envite.greenbpm.api.carbon.aware;

import com.google.gson.reflect.TypeToken;
import de.envite.greenbpm.api.carbon.aware.model.CarbonIntensityBatchParametersDTO;
import de.envite.greenbpm.api.carbon.aware.model.CarbonIntensityDTO;
import de.envite.greenbpm.api.carbon.aware.model.EmissionsData;
import de.envite.greenbpm.api.carbon.aware.model.EmissionsForecastBatchParametersDTO;
import de.envite.greenbpm.api.carbon.aware.model.EmissionsForecastDTO;
import java.io.IOException;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.threeten.bp.OffsetDateTime;

public class CarbonAwareApi {
  private ApiClient apiClient;

  public CarbonAwareApi() {
    this(Configuration.getDefaultApiClient());
  }

  public CarbonAwareApi(ApiClient apiClient) {
    this.apiClient = apiClient;
  }

  public ApiClient getApiClient() {
    return apiClient;
  }

  public void setApiClient(ApiClient apiClient) {
    this.apiClient = apiClient;
  }

  /**
   * Build call for batchForecastDataAsync
   *
   * @param body Array of requested forecasts. (optional)
   * @param progressListener Progress listener
   * @param progressRequestListener Progress request listener
   * @return Call to execute
   * @throws ApiException If fail to serialize the request body object
   */
  public com.squareup.okhttp.Call batchForecastDataAsyncCall(
      List<EmissionsForecastBatchParametersDTO> body,
      final ProgressResponseBody.ProgressListener progressListener,
      final ProgressRequestBody.ProgressRequestListener progressRequestListener)
      throws ApiException {
    Object localVarPostBody = body;

    // create path and map variables
    String localVarPath = "/emissions/forecasts/batch";

    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

    Map<String, String> localVarHeaderParams = new HashMap<String, String>();

    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    final String[] localVarAccepts = {"application/json"};
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
    if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

    final String[] localVarContentTypes = {"application/json", "text/json", "application/_*+json"};
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
    localVarHeaderParams.put("Content-Type", localVarContentType);

    if (progressListener != null) {
      apiClient
          .getHttpClient()
          .networkInterceptors()
          .add(
              new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(
                    com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                  com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                  return originalResponse
                      .newBuilder()
                      .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                      .build();
                }
              });
    }

    String[] localVarAuthNames = new String[] {};
    return apiClient.buildCall(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarPostBody,
        localVarHeaderParams,
        localVarFormParams,
        localVarAuthNames,
        progressRequestListener);
  }

  @SuppressWarnings("rawtypes")
  private com.squareup.okhttp.Call batchForecastDataAsyncValidateBeforeCall(
      List<EmissionsForecastBatchParametersDTO> body,
      final ProgressResponseBody.ProgressListener progressListener,
      final ProgressRequestBody.ProgressRequestListener progressRequestListener)
      throws ApiException {

    com.squareup.okhttp.Call call =
        batchForecastDataAsyncCall(body, progressListener, progressRequestListener);
    return call;
  }

  /**
   * Given an array of historical forecasts, retrieves the data that contains forecasts metadata,
   * the optimal forecast and a range of forecasts filtered by the attributes [start...end] if
   * provided. This endpoint takes a batch of requests for historical forecast data, fetches them,
   * and calculates the optimal marginal carbon intensity windows for each using the same parameters
   * available to the &#x27;/emissions/forecasts/current&#x27; endpoint. This endpoint is useful for
   * back-testing what one might have done in the past, if they had access to the current forecast
   * at the time.
   *
   * @param body Array of requested forecasts. (optional)
   * @return List&lt;EmissionsForecastDTO&gt;
   * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
   *     response body
   */
  public List<EmissionsForecastDTO> batchForecastDataAsync(
      List<EmissionsForecastBatchParametersDTO> body) throws ApiException {
    ApiResponse<List<EmissionsForecastDTO>> resp = batchForecastDataAsyncWithHttpInfo(body);
    return resp.getData();
  }

  /**
   * Given an array of historical forecasts, retrieves the data that contains forecasts metadata,
   * the optimal forecast and a range of forecasts filtered by the attributes [start...end] if
   * provided. This endpoint takes a batch of requests for historical forecast data, fetches them,
   * and calculates the optimal marginal carbon intensity windows for each using the same parameters
   * available to the &#x27;/emissions/forecasts/current&#x27; endpoint. This endpoint is useful for
   * back-testing what one might have done in the past, if they had access to the current forecast
   * at the time.
   *
   * @param body Array of requested forecasts. (optional)
   * @return ApiResponse&lt;List&lt;EmissionsForecastDTO&gt;&gt;
   * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
   *     response body
   */
  public ApiResponse<List<EmissionsForecastDTO>> batchForecastDataAsyncWithHttpInfo(
      List<EmissionsForecastBatchParametersDTO> body) throws ApiException {
    com.squareup.okhttp.Call call = batchForecastDataAsyncValidateBeforeCall(body, null, null);
    Type localVarReturnType = new TypeToken<List<EmissionsForecastDTO>>() {}.getType();
    return apiClient.execute(call, localVarReturnType);
  }

  /**
   * Given an array of historical forecasts, retrieves the data that contains forecasts metadata,
   * the optimal forecast and a range of forecasts filtered by the attributes [start...end] if
   * provided. (asynchronously) This endpoint takes a batch of requests for historical forecast
   * data, fetches them, and calculates the optimal marginal carbon intensity windows for each using
   * the same parameters available to the &#x27;/emissions/forecasts/current&#x27; endpoint. This
   * endpoint is useful for back-testing what one might have done in the past, if they had access to
   * the current forecast at the time.
   *
   * @param body Array of requested forecasts. (optional)
   * @param callback The callback to be executed when the API call finishes
   * @return The request call
   * @throws ApiException If fail to process the API call, e.g. serializing the request body object
   */
  public com.squareup.okhttp.Call batchForecastDataAsyncAsync(
      List<EmissionsForecastBatchParametersDTO> body,
      final ApiCallback<List<EmissionsForecastDTO>> callback)
      throws ApiException {

    ProgressResponseBody.ProgressListener progressListener = null;
    ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

    if (callback != null) {
      progressListener =
          new ProgressResponseBody.ProgressListener() {
            @Override
            public void update(long bytesRead, long contentLength, boolean done) {
              callback.onDownloadProgress(bytesRead, contentLength, done);
            }
          };

      progressRequestListener =
          new ProgressRequestBody.ProgressRequestListener() {
            @Override
            public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
              callback.onUploadProgress(bytesWritten, contentLength, done);
            }
          };
    }

    com.squareup.okhttp.Call call =
        batchForecastDataAsyncValidateBeforeCall(body, progressListener, progressRequestListener);
    Type localVarReturnType = new TypeToken<List<EmissionsForecastDTO>>() {}.getType();
    apiClient.executeAsync(call, localVarReturnType, callback);
    return call;
  }
  /**
   * Build call for getAverageCarbonIntensity
   *
   * @param location The location name where workflow is run (required)
   * @param startTime The time at which the workflow we are measuring carbon intensity for started
   *     (required)
   * @param endTime The time at which the workflow we are measuring carbon intensity for ended
   *     (required)
   * @param progressListener Progress listener
   * @param progressRequestListener Progress request listener
   * @return Call to execute
   * @throws ApiException If fail to serialize the request body object
   */
  public com.squareup.okhttp.Call getAverageCarbonIntensityCall(
      String location,
      OffsetDateTime startTime,
      OffsetDateTime endTime,
      final ProgressResponseBody.ProgressListener progressListener,
      final ProgressRequestBody.ProgressRequestListener progressRequestListener)
      throws ApiException {
    Object localVarPostBody = null;

    // create path and map variables
    String localVarPath = "/emissions/average-carbon-intensity";

    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    if (location != null)
      localVarQueryParams.addAll(apiClient.parameterToPair("location", location));
    if (startTime != null)
      localVarQueryParams.addAll(apiClient.parameterToPair("startTime", startTime));
    if (endTime != null) localVarQueryParams.addAll(apiClient.parameterToPair("endTime", endTime));

    Map<String, String> localVarHeaderParams = new HashMap<String, String>();

    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    final String[] localVarAccepts = {"application/json"};
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
    if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

    final String[] localVarContentTypes = {};

    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
    localVarHeaderParams.put("Content-Type", localVarContentType);

    if (progressListener != null) {
      apiClient
          .getHttpClient()
          .networkInterceptors()
          .add(
              new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(
                    com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                  com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                  return originalResponse
                      .newBuilder()
                      .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                      .build();
                }
              });
    }

    String[] localVarAuthNames = new String[] {};
    return apiClient.buildCall(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarPostBody,
        localVarHeaderParams,
        localVarFormParams,
        localVarAuthNames,
        progressRequestListener);
  }

  @SuppressWarnings("rawtypes")
  private com.squareup.okhttp.Call getAverageCarbonIntensityValidateBeforeCall(
      String location,
      OffsetDateTime startTime,
      OffsetDateTime endTime,
      final ProgressResponseBody.ProgressListener progressListener,
      final ProgressRequestBody.ProgressRequestListener progressRequestListener)
      throws ApiException {
    // verify the required parameter 'location' is set
    if (location == null) {
      throw new ApiException(
          "Missing the required parameter 'location' when calling getAverageCarbonIntensity(Async)");
    }
    // verify the required parameter 'startTime' is set
    if (startTime == null) {
      throw new ApiException(
          "Missing the required parameter 'startTime' when calling getAverageCarbonIntensity(Async)");
    }
    // verify the required parameter 'endTime' is set
    if (endTime == null) {
      throw new ApiException(
          "Missing the required parameter 'endTime' when calling getAverageCarbonIntensity(Async)");
    }

    com.squareup.okhttp.Call call =
        getAverageCarbonIntensityCall(
            location, startTime, endTime, progressListener, progressRequestListener);
    return call;
  }

  /**
   * Retrieves the measured carbon intensity data between the time boundaries and calculates the
   * average carbon intensity during that period. This endpoint is useful for reporting the measured
   * carbon intensity for a specific time period in a specific location.
   *
   * @param location The location name where workflow is run (required)
   * @param startTime The time at which the workflow we are measuring carbon intensity for started
   *     (required)
   * @param endTime The time at which the workflow we are measuring carbon intensity for ended
   *     (required)
   * @return CarbonIntensityDTO
   * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
   *     response body
   */
  public CarbonIntensityDTO getAverageCarbonIntensity(
      String location, OffsetDateTime startTime, OffsetDateTime endTime) throws ApiException {
    ApiResponse<CarbonIntensityDTO> resp =
        getAverageCarbonIntensityWithHttpInfo(location, startTime, endTime);
    return resp.getData();
  }

  /**
   * Retrieves the measured carbon intensity data between the time boundaries and calculates the
   * average carbon intensity during that period. This endpoint is useful for reporting the measured
   * carbon intensity for a specific time period in a specific location.
   *
   * @param location The location name where workflow is run (required)
   * @param startTime The time at which the workflow we are measuring carbon intensity for started
   *     (required)
   * @param endTime The time at which the workflow we are measuring carbon intensity for ended
   *     (required)
   * @return ApiResponse&lt;CarbonIntensityDTO&gt;
   * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
   *     response body
   */
  public ApiResponse<CarbonIntensityDTO> getAverageCarbonIntensityWithHttpInfo(
      String location, OffsetDateTime startTime, OffsetDateTime endTime) throws ApiException {
    com.squareup.okhttp.Call call =
        getAverageCarbonIntensityValidateBeforeCall(location, startTime, endTime, null, null);
    Type localVarReturnType = new TypeToken<CarbonIntensityDTO>() {}.getType();
    return apiClient.execute(call, localVarReturnType);
  }

  /**
   * Retrieves the measured carbon intensity data between the time boundaries and calculates the
   * average carbon intensity during that period. (asynchronously) This endpoint is useful for
   * reporting the measured carbon intensity for a specific time period in a specific location.
   *
   * @param location The location name where workflow is run (required)
   * @param startTime The time at which the workflow we are measuring carbon intensity for started
   *     (required)
   * @param endTime The time at which the workflow we are measuring carbon intensity for ended
   *     (required)
   * @param callback The callback to be executed when the API call finishes
   * @return The request call
   * @throws ApiException If fail to process the API call, e.g. serializing the request body object
   */
  public com.squareup.okhttp.Call getAverageCarbonIntensityAsync(
      String location,
      OffsetDateTime startTime,
      OffsetDateTime endTime,
      final ApiCallback<CarbonIntensityDTO> callback)
      throws ApiException {

    ProgressResponseBody.ProgressListener progressListener = null;
    ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

    if (callback != null) {
      progressListener =
          new ProgressResponseBody.ProgressListener() {
            @Override
            public void update(long bytesRead, long contentLength, boolean done) {
              callback.onDownloadProgress(bytesRead, contentLength, done);
            }
          };

      progressRequestListener =
          new ProgressRequestBody.ProgressRequestListener() {
            @Override
            public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
              callback.onUploadProgress(bytesWritten, contentLength, done);
            }
          };
    }

    com.squareup.okhttp.Call call =
        getAverageCarbonIntensityValidateBeforeCall(
            location, startTime, endTime, progressListener, progressRequestListener);
    Type localVarReturnType = new TypeToken<CarbonIntensityDTO>() {}.getType();
    apiClient.executeAsync(call, localVarReturnType, callback);
    return call;
  }
  /**
   * Build call for getAverageCarbonIntensityBatch
   *
   * @param body Array of inputs where each contains a &quot;location&quot;, &quot;startDate&quot;,
   *     and &quot;endDate&quot; for which to calculate average marginal carbon intensity.
   *     (optional)
   * @param progressListener Progress listener
   * @param progressRequestListener Progress request listener
   * @return Call to execute
   * @throws ApiException If fail to serialize the request body object
   */
  public com.squareup.okhttp.Call getAverageCarbonIntensityBatchCall(
      List<CarbonIntensityBatchParametersDTO> body,
      final ProgressResponseBody.ProgressListener progressListener,
      final ProgressRequestBody.ProgressRequestListener progressRequestListener)
      throws ApiException {
    Object localVarPostBody = body;

    // create path and map variables
    String localVarPath = "/emissions/average-carbon-intensity/batch";

    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

    Map<String, String> localVarHeaderParams = new HashMap<String, String>();

    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    final String[] localVarAccepts = {"application/json"};
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
    if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

    final String[] localVarContentTypes = {"application/json", "text/json", "application/_*+json"};
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
    localVarHeaderParams.put("Content-Type", localVarContentType);

    if (progressListener != null) {
      apiClient
          .getHttpClient()
          .networkInterceptors()
          .add(
              new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(
                    com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                  com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                  return originalResponse
                      .newBuilder()
                      .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                      .build();
                }
              });
    }

    String[] localVarAuthNames = new String[] {};
    return apiClient.buildCall(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarPostBody,
        localVarHeaderParams,
        localVarFormParams,
        localVarAuthNames,
        progressRequestListener);
  }

  @SuppressWarnings("rawtypes")
  private com.squareup.okhttp.Call getAverageCarbonIntensityBatchValidateBeforeCall(
      List<CarbonIntensityBatchParametersDTO> body,
      final ProgressResponseBody.ProgressListener progressListener,
      final ProgressRequestBody.ProgressRequestListener progressRequestListener)
      throws ApiException {

    com.squareup.okhttp.Call call =
        getAverageCarbonIntensityBatchCall(body, progressListener, progressRequestListener);
    return call;
  }

  /**
   * Given an array of request objects, each with their own location and time boundaries, calculate
   * the average carbon intensity for that location and time period and return an array of carbon
   * intensity objects. The application only supports batching across a single location with
   * different time boundaries. If multiple locations are provided, an error is returned. For each
   * item in the request array, the application returns a corresponding object containing the
   * location, time boundaries, and average marginal carbon intensity.
   *
   * @param body Array of inputs where each contains a &quot;location&quot;, &quot;startDate&quot;,
   *     and &quot;endDate&quot; for which to calculate average marginal carbon intensity.
   *     (optional)
   * @return List&lt;CarbonIntensityDTO&gt;
   * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
   *     response body
   */
  public List<CarbonIntensityDTO> getAverageCarbonIntensityBatch(
      List<CarbonIntensityBatchParametersDTO> body) throws ApiException {
    ApiResponse<List<CarbonIntensityDTO>> resp = getAverageCarbonIntensityBatchWithHttpInfo(body);
    return resp.getData();
  }

  /**
   * Given an array of request objects, each with their own location and time boundaries, calculate
   * the average carbon intensity for that location and time period and return an array of carbon
   * intensity objects. The application only supports batching across a single location with
   * different time boundaries. If multiple locations are provided, an error is returned. For each
   * item in the request array, the application returns a corresponding object containing the
   * location, time boundaries, and average marginal carbon intensity.
   *
   * @param body Array of inputs where each contains a &quot;location&quot;, &quot;startDate&quot;,
   *     and &quot;endDate&quot; for which to calculate average marginal carbon intensity.
   *     (optional)
   * @return ApiResponse&lt;List&lt;CarbonIntensityDTO&gt;&gt;
   * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
   *     response body
   */
  public ApiResponse<List<CarbonIntensityDTO>> getAverageCarbonIntensityBatchWithHttpInfo(
      List<CarbonIntensityBatchParametersDTO> body) throws ApiException {
    com.squareup.okhttp.Call call =
        getAverageCarbonIntensityBatchValidateBeforeCall(body, null, null);
    Type localVarReturnType = new TypeToken<List<CarbonIntensityDTO>>() {}.getType();
    return apiClient.execute(call, localVarReturnType);
  }

  /**
   * Given an array of request objects, each with their own location and time boundaries, calculate
   * the average carbon intensity for that location and time period and return an array of carbon
   * intensity objects. (asynchronously) The application only supports batching across a single
   * location with different time boundaries. If multiple locations are provided, an error is
   * returned. For each item in the request array, the application returns a corresponding object
   * containing the location, time boundaries, and average marginal carbon intensity.
   *
   * @param body Array of inputs where each contains a &quot;location&quot;, &quot;startDate&quot;,
   *     and &quot;endDate&quot; for which to calculate average marginal carbon intensity.
   *     (optional)
   * @param callback The callback to be executed when the API call finishes
   * @return The request call
   * @throws ApiException If fail to process the API call, e.g. serializing the request body object
   */
  public com.squareup.okhttp.Call getAverageCarbonIntensityBatchAsync(
      List<CarbonIntensityBatchParametersDTO> body,
      final ApiCallback<List<CarbonIntensityDTO>> callback)
      throws ApiException {

    ProgressResponseBody.ProgressListener progressListener = null;
    ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

    if (callback != null) {
      progressListener =
          new ProgressResponseBody.ProgressListener() {
            @Override
            public void update(long bytesRead, long contentLength, boolean done) {
              callback.onDownloadProgress(bytesRead, contentLength, done);
            }
          };

      progressRequestListener =
          new ProgressRequestBody.ProgressRequestListener() {
            @Override
            public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
              callback.onUploadProgress(bytesWritten, contentLength, done);
            }
          };
    }

    com.squareup.okhttp.Call call =
        getAverageCarbonIntensityBatchValidateBeforeCall(
            body, progressListener, progressRequestListener);
    Type localVarReturnType = new TypeToken<List<CarbonIntensityDTO>>() {}.getType();
    apiClient.executeAsync(call, localVarReturnType, callback);
    return call;
  }
  /**
   * Build call for getBestEmissionsDataForLocationsByTime
   *
   * @param location String array of named locations (required)
   * @param time [Optional] Start time for the data query. (optional)
   * @param toTime [Optional] End time for the data query. (optional)
   * @param progressListener Progress listener
   * @param progressRequestListener Progress request listener
   * @return Call to execute
   * @throws ApiException If fail to serialize the request body object
   */
  public com.squareup.okhttp.Call getBestEmissionsDataForLocationsByTimeCall(
      List<String> location,
      OffsetDateTime time,
      OffsetDateTime toTime,
      final ProgressResponseBody.ProgressListener progressListener,
      final ProgressRequestBody.ProgressRequestListener progressRequestListener)
      throws ApiException {
    Object localVarPostBody = null;

    // create path and map variables
    String localVarPath = "/emissions/bylocations/best";

    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    if (location != null)
      localVarCollectionQueryParams.addAll(
          apiClient.parameterToPairs("multi", "location", location));
    if (time != null) localVarQueryParams.addAll(apiClient.parameterToPair("time", time));
    if (toTime != null) localVarQueryParams.addAll(apiClient.parameterToPair("toTime", toTime));

    Map<String, String> localVarHeaderParams = new HashMap<String, String>();

    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    final String[] localVarAccepts = {"application/json"};
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
    if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

    final String[] localVarContentTypes = {};

    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
    localVarHeaderParams.put("Content-Type", localVarContentType);

    if (progressListener != null) {
      apiClient
          .getHttpClient()
          .networkInterceptors()
          .add(
              new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(
                    com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                  com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                  return originalResponse
                      .newBuilder()
                      .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                      .build();
                }
              });
    }

    String[] localVarAuthNames = new String[] {};
    return apiClient.buildCall(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarPostBody,
        localVarHeaderParams,
        localVarFormParams,
        localVarAuthNames,
        progressRequestListener);
  }

  @SuppressWarnings("rawtypes")
  private com.squareup.okhttp.Call getBestEmissionsDataForLocationsByTimeValidateBeforeCall(
      List<String> location,
      OffsetDateTime time,
      OffsetDateTime toTime,
      final ProgressResponseBody.ProgressListener progressListener,
      final ProgressRequestBody.ProgressRequestListener progressRequestListener)
      throws ApiException {
    // verify the required parameter 'location' is set
    if (location == null) {
      throw new ApiException(
          "Missing the required parameter 'location' when calling getBestEmissionsDataForLocationsByTime(Async)");
    }

    com.squareup.okhttp.Call call =
        getBestEmissionsDataForLocationsByTimeCall(
            location, time, toTime, progressListener, progressRequestListener);
    return call;
  }

  /**
   * Calculate the best emission data by list of locations for a specified time period.
   *
   * @param location String array of named locations (required)
   * @param time [Optional] Start time for the data query. (optional)
   * @param toTime [Optional] End time for the data query. (optional)
   * @return List&lt;EmissionsData&gt;
   * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
   *     response body
   */
  public List<EmissionsData> getBestEmissionsDataForLocationsByTime(
      List<String> location, OffsetDateTime time, OffsetDateTime toTime) throws ApiException {
    ApiResponse<List<EmissionsData>> resp =
        getBestEmissionsDataForLocationsByTimeWithHttpInfo(location, time, toTime);
    return resp.getData();
  }

  /**
   * Calculate the best emission data by list of locations for a specified time period.
   *
   * @param location String array of named locations (required)
   * @param time [Optional] Start time for the data query. (optional)
   * @param toTime [Optional] End time for the data query. (optional)
   * @return ApiResponse&lt;List&lt;EmissionsData&gt;&gt;
   * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
   *     response body
   */
  public ApiResponse<List<EmissionsData>> getBestEmissionsDataForLocationsByTimeWithHttpInfo(
      List<String> location, OffsetDateTime time, OffsetDateTime toTime) throws ApiException {
    com.squareup.okhttp.Call call =
        getBestEmissionsDataForLocationsByTimeValidateBeforeCall(
            location, time, toTime, null, null);
    Type localVarReturnType = new TypeToken<List<EmissionsData>>() {}.getType();
    return apiClient.execute(call, localVarReturnType);
  }

  /**
   * Calculate the best emission data by list of locations for a specified time period.
   * (asynchronously)
   *
   * @param location String array of named locations (required)
   * @param time [Optional] Start time for the data query. (optional)
   * @param toTime [Optional] End time for the data query. (optional)
   * @param callback The callback to be executed when the API call finishes
   * @return The request call
   * @throws ApiException If fail to process the API call, e.g. serializing the request body object
   */
  public com.squareup.okhttp.Call getBestEmissionsDataForLocationsByTimeAsync(
      List<String> location,
      OffsetDateTime time,
      OffsetDateTime toTime,
      final ApiCallback<List<EmissionsData>> callback)
      throws ApiException {

    ProgressResponseBody.ProgressListener progressListener = null;
    ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

    if (callback != null) {
      progressListener =
          new ProgressResponseBody.ProgressListener() {
            @Override
            public void update(long bytesRead, long contentLength, boolean done) {
              callback.onDownloadProgress(bytesRead, contentLength, done);
            }
          };

      progressRequestListener =
          new ProgressRequestBody.ProgressRequestListener() {
            @Override
            public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
              callback.onUploadProgress(bytesWritten, contentLength, done);
            }
          };
    }

    com.squareup.okhttp.Call call =
        getBestEmissionsDataForLocationsByTimeValidateBeforeCall(
            location, time, toTime, progressListener, progressRequestListener);
    Type localVarReturnType = new TypeToken<List<EmissionsData>>() {}.getType();
    apiClient.executeAsync(call, localVarReturnType, callback);
    return call;
  }
  /**
   * Build call for getCurrentForecastData
   *
   * @param location String array of named locations (required)
   * @param dataStartAt Start time boundary of forecasted data points.Ignores current forecast data
   *     points before this time. Defaults to the earliest time in the forecast data. (optional)
   * @param dataEndAt End time boundary of forecasted data points. Ignores current forecast data
   *     points after this time. Defaults to the latest time in the forecast data. (optional)
   * @param windowSize The estimated duration (in minutes) of the workload. Defaults to the duration
   *     of a single forecast data point. (optional)
   * @param progressListener Progress listener
   * @param progressRequestListener Progress request listener
   * @return Call to execute
   * @throws ApiException If fail to serialize the request body object
   */
  public com.squareup.okhttp.Call getCurrentForecastDataCall(
      List<String> location,
      OffsetDateTime dataStartAt,
      OffsetDateTime dataEndAt,
      Integer windowSize,
      final ProgressResponseBody.ProgressListener progressListener,
      final ProgressRequestBody.ProgressRequestListener progressRequestListener)
      throws ApiException {
    Object localVarPostBody = null;

    // create path and map variables
    String localVarPath = "/emissions/forecasts/current";

    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    if (location != null)
      localVarCollectionQueryParams.addAll(
          apiClient.parameterToPairs("multi", "location", location));
    if (dataStartAt != null)
      localVarQueryParams.addAll(apiClient.parameterToPair("dataStartAt", dataStartAt));
    if (dataEndAt != null)
      localVarQueryParams.addAll(apiClient.parameterToPair("dataEndAt", dataEndAt));
    if (windowSize != null)
      localVarQueryParams.addAll(apiClient.parameterToPair("windowSize", windowSize));

    Map<String, String> localVarHeaderParams = new HashMap<String, String>();

    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    final String[] localVarAccepts = {"application/json"};
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
    if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

    final String[] localVarContentTypes = {};

    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
    localVarHeaderParams.put("Content-Type", localVarContentType);

    if (progressListener != null) {
      apiClient
          .getHttpClient()
          .networkInterceptors()
          .add(
              new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(
                    com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                  com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                  return originalResponse
                      .newBuilder()
                      .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                      .build();
                }
              });
    }

    String[] localVarAuthNames = new String[] {};
    return apiClient.buildCall(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarPostBody,
        localVarHeaderParams,
        localVarFormParams,
        localVarAuthNames,
        progressRequestListener);
  }

  @SuppressWarnings("rawtypes")
  private com.squareup.okhttp.Call getCurrentForecastDataValidateBeforeCall(
      List<String> location,
      OffsetDateTime dataStartAt,
      OffsetDateTime dataEndAt,
      Integer windowSize,
      final ProgressResponseBody.ProgressListener progressListener,
      final ProgressRequestBody.ProgressRequestListener progressRequestListener)
      throws ApiException {
    // verify the required parameter 'location' is set
    if (location == null) {
      throw new ApiException(
          "Missing the required parameter 'location' when calling getCurrentForecastData(Async)");
    }

    com.squareup.okhttp.Call call =
        getCurrentForecastDataCall(
            location,
            dataStartAt,
            dataEndAt,
            windowSize,
            progressListener,
            progressRequestListener);
    return call;
  }

  /**
   * Retrieves the most recent forecasted data and calculates the optimal marginal carbon intensity
   * window. This endpoint fetches only the most recently generated forecast for all provided
   * locations. It uses the \&quot;dataStartAt\&quot; and \&quot;dataEndAt\&quot; parameters to
   * scope the forecasted data points (if available for those times). If no start or end time
   * boundaries are provided, the entire forecast dataset is used. The scoped data points are used
   * to calculate average marginal carbon intensities of the specified \&quot;windowSize\&quot; and
   * the optimal marginal carbon intensity window is identified. The forecast data represents what
   * the data source predicts future marginal carbon intesity values to be, not actual measured
   * emissions data (as future values cannot be known). This endpoint is useful for determining if
   * there is a more carbon-optimal time to use electicity predicted in the future.
   *
   * @param location String array of named locations (required)
   * @param dataStartAt Start time boundary of forecasted data points.Ignores current forecast data
   *     points before this time. Defaults to the earliest time in the forecast data. (optional)
   * @param dataEndAt End time boundary of forecasted data points. Ignores current forecast data
   *     points after this time. Defaults to the latest time in the forecast data. (optional)
   * @param windowSize The estimated duration (in minutes) of the workload. Defaults to the duration
   *     of a single forecast data point. (optional)
   * @return List&lt;EmissionsForecastDTO&gt;
   * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
   *     response body
   */
  public List<EmissionsForecastDTO> getCurrentForecastData(
      List<String> location,
      OffsetDateTime dataStartAt,
      OffsetDateTime dataEndAt,
      Integer windowSize)
      throws ApiException {
    ApiResponse<List<EmissionsForecastDTO>> resp =
        getCurrentForecastDataWithHttpInfo(location, dataStartAt, dataEndAt, windowSize);
    return resp.getData();
  }

  /**
   * Retrieves the most recent forecasted data and calculates the optimal marginal carbon intensity
   * window. This endpoint fetches only the most recently generated forecast for all provided
   * locations. It uses the \&quot;dataStartAt\&quot; and \&quot;dataEndAt\&quot; parameters to
   * scope the forecasted data points (if available for those times). If no start or end time
   * boundaries are provided, the entire forecast dataset is used. The scoped data points are used
   * to calculate average marginal carbon intensities of the specified \&quot;windowSize\&quot; and
   * the optimal marginal carbon intensity window is identified. The forecast data represents what
   * the data source predicts future marginal carbon intesity values to be, not actual measured
   * emissions data (as future values cannot be known). This endpoint is useful for determining if
   * there is a more carbon-optimal time to use electicity predicted in the future.
   *
   * @param location String array of named locations (required)
   * @param dataStartAt Start time boundary of forecasted data points.Ignores current forecast data
   *     points before this time. Defaults to the earliest time in the forecast data. (optional)
   * @param dataEndAt End time boundary of forecasted data points. Ignores current forecast data
   *     points after this time. Defaults to the latest time in the forecast data. (optional)
   * @param windowSize The estimated duration (in minutes) of the workload. Defaults to the duration
   *     of a single forecast data point. (optional)
   * @return ApiResponse&lt;List&lt;EmissionsForecastDTO&gt;&gt;
   * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
   *     response body
   */
  public ApiResponse<List<EmissionsForecastDTO>> getCurrentForecastDataWithHttpInfo(
      List<String> location,
      OffsetDateTime dataStartAt,
      OffsetDateTime dataEndAt,
      Integer windowSize)
      throws ApiException {
    com.squareup.okhttp.Call call =
        getCurrentForecastDataValidateBeforeCall(
            location, dataStartAt, dataEndAt, windowSize, null, null);
    Type localVarReturnType = new TypeToken<List<EmissionsForecastDTO>>() {}.getType();
    return apiClient.execute(call, localVarReturnType);
  }

  /**
   * Retrieves the most recent forecasted data and calculates the optimal marginal carbon intensity
   * window. (asynchronously) This endpoint fetches only the most recently generated forecast for
   * all provided locations. It uses the \&quot;dataStartAt\&quot; and \&quot;dataEndAt\&quot;
   * parameters to scope the forecasted data points (if available for those times). If no start or
   * end time boundaries are provided, the entire forecast dataset is used. The scoped data points
   * are used to calculate average marginal carbon intensities of the specified
   * \&quot;windowSize\&quot; and the optimal marginal carbon intensity window is identified. The
   * forecast data represents what the data source predicts future marginal carbon intesity values
   * to be, not actual measured emissions data (as future values cannot be known). This endpoint is
   * useful for determining if there is a more carbon-optimal time to use electicity predicted in
   * the future.
   *
   * @param location String array of named locations (required)
   * @param dataStartAt Start time boundary of forecasted data points.Ignores current forecast data
   *     points before this time. Defaults to the earliest time in the forecast data. (optional)
   * @param dataEndAt End time boundary of forecasted data points. Ignores current forecast data
   *     points after this time. Defaults to the latest time in the forecast data. (optional)
   * @param windowSize The estimated duration (in minutes) of the workload. Defaults to the duration
   *     of a single forecast data point. (optional)
   * @param callback The callback to be executed when the API call finishes
   * @return The request call
   * @throws ApiException If fail to process the API call, e.g. serializing the request body object
   */
  public com.squareup.okhttp.Call getCurrentForecastDataAsync(
      List<String> location,
      OffsetDateTime dataStartAt,
      OffsetDateTime dataEndAt,
      Integer windowSize,
      final ApiCallback<List<EmissionsForecastDTO>> callback)
      throws ApiException {

    ProgressResponseBody.ProgressListener progressListener = null;
    ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

    if (callback != null) {
      progressListener =
          new ProgressResponseBody.ProgressListener() {
            @Override
            public void update(long bytesRead, long contentLength, boolean done) {
              callback.onDownloadProgress(bytesRead, contentLength, done);
            }
          };

      progressRequestListener =
          new ProgressRequestBody.ProgressRequestListener() {
            @Override
            public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
              callback.onUploadProgress(bytesWritten, contentLength, done);
            }
          };
    }

    com.squareup.okhttp.Call call =
        getCurrentForecastDataValidateBeforeCall(
            location,
            dataStartAt,
            dataEndAt,
            windowSize,
            progressListener,
            progressRequestListener);
    Type localVarReturnType = new TypeToken<List<EmissionsForecastDTO>>() {}.getType();
    apiClient.executeAsync(call, localVarReturnType, callback);
    return call;
  }
  /**
   * Build call for getEmissionsDataForLocationByTime
   *
   * @param location String named location. (required)
   * @param time [Optional] Start time for the data query. (optional)
   * @param toTime [Optional] End time for the data query. (optional)
   * @param progressListener Progress listener
   * @param progressRequestListener Progress request listener
   * @return Call to execute
   * @throws ApiException If fail to serialize the request body object
   */
  public com.squareup.okhttp.Call getEmissionsDataForLocationByTimeCall(
      String location,
      OffsetDateTime time,
      OffsetDateTime toTime,
      final ProgressResponseBody.ProgressListener progressListener,
      final ProgressRequestBody.ProgressRequestListener progressRequestListener)
      throws ApiException {
    Object localVarPostBody = null;

    // create path and map variables
    String localVarPath = "/emissions/bylocation";

    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    if (location != null)
      localVarQueryParams.addAll(apiClient.parameterToPair("location", location));
    if (time != null) localVarQueryParams.addAll(apiClient.parameterToPair("time", time));
    if (toTime != null) localVarQueryParams.addAll(apiClient.parameterToPair("toTime", toTime));

    Map<String, String> localVarHeaderParams = new HashMap<String, String>();

    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    final String[] localVarAccepts = {"application/json"};
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
    if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

    final String[] localVarContentTypes = {};

    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
    localVarHeaderParams.put("Content-Type", localVarContentType);

    if (progressListener != null) {
      apiClient
          .getHttpClient()
          .networkInterceptors()
          .add(
              new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(
                    com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                  com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                  return originalResponse
                      .newBuilder()
                      .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                      .build();
                }
              });
    }

    String[] localVarAuthNames = new String[] {};
    return apiClient.buildCall(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarPostBody,
        localVarHeaderParams,
        localVarFormParams,
        localVarAuthNames,
        progressRequestListener);
  }

  @SuppressWarnings("rawtypes")
  private com.squareup.okhttp.Call getEmissionsDataForLocationByTimeValidateBeforeCall(
      String location,
      OffsetDateTime time,
      OffsetDateTime toTime,
      final ProgressResponseBody.ProgressListener progressListener,
      final ProgressRequestBody.ProgressRequestListener progressRequestListener)
      throws ApiException {
    // verify the required parameter 'location' is set
    if (location == null) {
      throw new ApiException(
          "Missing the required parameter 'location' when calling getEmissionsDataForLocationByTime(Async)");
    }

    com.squareup.okhttp.Call call =
        getEmissionsDataForLocationByTimeCall(
            location, time, toTime, progressListener, progressRequestListener);
    return call;
  }

  /**
   * Calculate the best emission data by location for a specified time period.
   *
   * @param location String named location. (required)
   * @param time [Optional] Start time for the data query. (optional)
   * @param toTime [Optional] End time for the data query. (optional)
   * @return List&lt;EmissionsData&gt;
   * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
   *     response body
   */
  public List<EmissionsData> getEmissionsDataForLocationByTime(
      String location, OffsetDateTime time, OffsetDateTime toTime) throws ApiException {
    ApiResponse<List<EmissionsData>> resp =
        getEmissionsDataForLocationByTimeWithHttpInfo(location, time, toTime);
    return resp.getData();
  }

  /**
   * Calculate the best emission data by location for a specified time period.
   *
   * @param location String named location. (required)
   * @param time [Optional] Start time for the data query. (optional)
   * @param toTime [Optional] End time for the data query. (optional)
   * @return ApiResponse&lt;List&lt;EmissionsData&gt;&gt;
   * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
   *     response body
   */
  public ApiResponse<List<EmissionsData>> getEmissionsDataForLocationByTimeWithHttpInfo(
      String location, OffsetDateTime time, OffsetDateTime toTime) throws ApiException {
    com.squareup.okhttp.Call call =
        getEmissionsDataForLocationByTimeValidateBeforeCall(location, time, toTime, null, null);
    Type localVarReturnType = new TypeToken<List<EmissionsData>>() {}.getType();
    return apiClient.execute(call, localVarReturnType);
  }

  /**
   * Calculate the best emission data by location for a specified time period. (asynchronously)
   *
   * @param location String named location. (required)
   * @param time [Optional] Start time for the data query. (optional)
   * @param toTime [Optional] End time for the data query. (optional)
   * @param callback The callback to be executed when the API call finishes
   * @return The request call
   * @throws ApiException If fail to process the API call, e.g. serializing the request body object
   */
  public com.squareup.okhttp.Call getEmissionsDataForLocationByTimeAsync(
      String location,
      OffsetDateTime time,
      OffsetDateTime toTime,
      final ApiCallback<List<EmissionsData>> callback)
      throws ApiException {

    ProgressResponseBody.ProgressListener progressListener = null;
    ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

    if (callback != null) {
      progressListener =
          new ProgressResponseBody.ProgressListener() {
            @Override
            public void update(long bytesRead, long contentLength, boolean done) {
              callback.onDownloadProgress(bytesRead, contentLength, done);
            }
          };

      progressRequestListener =
          new ProgressRequestBody.ProgressRequestListener() {
            @Override
            public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
              callback.onUploadProgress(bytesWritten, contentLength, done);
            }
          };
    }

    com.squareup.okhttp.Call call =
        getEmissionsDataForLocationByTimeValidateBeforeCall(
            location, time, toTime, progressListener, progressRequestListener);
    Type localVarReturnType = new TypeToken<List<EmissionsData>>() {}.getType();
    apiClient.executeAsync(call, localVarReturnType, callback);
    return call;
  }
  /**
   * Build call for getEmissionsDataForLocationsByTime
   *
   * @param location String array of named locations (required)
   * @param time [Optional] Start time for the data query. (optional)
   * @param toTime [Optional] End time for the data query. (optional)
   * @param progressListener Progress listener
   * @param progressRequestListener Progress request listener
   * @return Call to execute
   * @throws ApiException If fail to serialize the request body object
   */
  public com.squareup.okhttp.Call getEmissionsDataForLocationsByTimeCall(
      List<String> location,
      OffsetDateTime time,
      OffsetDateTime toTime,
      final ProgressResponseBody.ProgressListener progressListener,
      final ProgressRequestBody.ProgressRequestListener progressRequestListener)
      throws ApiException {
    Object localVarPostBody = null;

    // create path and map variables
    String localVarPath = "/emissions/bylocations";

    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    if (location != null)
      localVarCollectionQueryParams.addAll(
          apiClient.parameterToPairs("multi", "location", location));
    if (time != null) localVarQueryParams.addAll(apiClient.parameterToPair("time", time));
    if (toTime != null) localVarQueryParams.addAll(apiClient.parameterToPair("toTime", toTime));

    Map<String, String> localVarHeaderParams = new HashMap<String, String>();

    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    final String[] localVarAccepts = {"application/json"};
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
    if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

    final String[] localVarContentTypes = {};

    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
    localVarHeaderParams.put("Content-Type", localVarContentType);

    if (progressListener != null) {
      apiClient
          .getHttpClient()
          .networkInterceptors()
          .add(
              new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(
                    com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                  com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                  return originalResponse
                      .newBuilder()
                      .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                      .build();
                }
              });
    }

    String[] localVarAuthNames = new String[] {};
    return apiClient.buildCall(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarPostBody,
        localVarHeaderParams,
        localVarFormParams,
        localVarAuthNames,
        progressRequestListener);
  }

  @SuppressWarnings("rawtypes")
  private com.squareup.okhttp.Call getEmissionsDataForLocationsByTimeValidateBeforeCall(
      List<String> location,
      OffsetDateTime time,
      OffsetDateTime toTime,
      final ProgressResponseBody.ProgressListener progressListener,
      final ProgressRequestBody.ProgressRequestListener progressRequestListener)
      throws ApiException {
    // verify the required parameter 'location' is set
    if (location == null) {
      throw new ApiException(
          "Missing the required parameter 'location' when calling getEmissionsDataForLocationsByTime(Async)");
    }

    com.squareup.okhttp.Call call =
        getEmissionsDataForLocationsByTimeCall(
            location, time, toTime, progressListener, progressRequestListener);
    return call;
  }

  /**
   * Calculate the observed emission data by list of locations for a specified time period.
   *
   * @param location String array of named locations (required)
   * @param time [Optional] Start time for the data query. (optional)
   * @param toTime [Optional] End time for the data query. (optional)
   * @return List&lt;EmissionsData&gt;
   * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
   *     response body
   */
  public List<EmissionsData> getEmissionsDataForLocationsByTime(
      List<String> location, OffsetDateTime time, OffsetDateTime toTime) throws ApiException {
    ApiResponse<List<EmissionsData>> resp =
        getEmissionsDataForLocationsByTimeWithHttpInfo(location, time, toTime);
    return resp.getData();
  }

  /**
   * Calculate the observed emission data by list of locations for a specified time period.
   *
   * @param location String array of named locations (required)
   * @param time [Optional] Start time for the data query. (optional)
   * @param toTime [Optional] End time for the data query. (optional)
   * @return ApiResponse&lt;List&lt;EmissionsData&gt;&gt;
   * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
   *     response body
   */
  public ApiResponse<List<EmissionsData>> getEmissionsDataForLocationsByTimeWithHttpInfo(
      List<String> location, OffsetDateTime time, OffsetDateTime toTime) throws ApiException {
    com.squareup.okhttp.Call call =
        getEmissionsDataForLocationsByTimeValidateBeforeCall(location, time, toTime, null, null);
    Type localVarReturnType = new TypeToken<List<EmissionsData>>() {}.getType();
    return apiClient.execute(call, localVarReturnType);
  }

  /**
   * Calculate the observed emission data by list of locations for a specified time period.
   * (asynchronously)
   *
   * @param location String array of named locations (required)
   * @param time [Optional] Start time for the data query. (optional)
   * @param toTime [Optional] End time for the data query. (optional)
   * @param callback The callback to be executed when the API call finishes
   * @return The request call
   * @throws ApiException If fail to process the API call, e.g. serializing the request body object
   */
  public com.squareup.okhttp.Call getEmissionsDataForLocationsByTimeAsync(
      List<String> location,
      OffsetDateTime time,
      OffsetDateTime toTime,
      final ApiCallback<List<EmissionsData>> callback)
      throws ApiException {

    ProgressResponseBody.ProgressListener progressListener = null;
    ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

    if (callback != null) {
      progressListener =
          new ProgressResponseBody.ProgressListener() {
            @Override
            public void update(long bytesRead, long contentLength, boolean done) {
              callback.onDownloadProgress(bytesRead, contentLength, done);
            }
          };

      progressRequestListener =
          new ProgressRequestBody.ProgressRequestListener() {
            @Override
            public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
              callback.onUploadProgress(bytesWritten, contentLength, done);
            }
          };
    }

    com.squareup.okhttp.Call call =
        getEmissionsDataForLocationsByTimeValidateBeforeCall(
            location, time, toTime, progressListener, progressRequestListener);
    Type localVarReturnType = new TypeToken<List<EmissionsData>>() {}.getType();
    apiClient.executeAsync(call, localVarReturnType, callback);
    return call;
  }
}
