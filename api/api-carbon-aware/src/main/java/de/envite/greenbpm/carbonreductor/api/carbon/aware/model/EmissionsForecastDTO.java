/*
 * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH
 * under one or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information regarding copyright
 * ownership. Camunda licenses this file to you under the Apache License,
 * Version 2.0; you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
 * CarbonAware.WebApi
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package de.envite.greenbpm.carbonreductor.api.carbon.aware.model;

import com.google.gson.annotations.SerializedName;
import io.swagger.v3.oas.annotations.media.Schema;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import org.threeten.bp.OffsetDateTime;

/** EmissionsForecastDTO */
@javax.annotation.Generated(
    value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen",
    date = "2022-10-17T16:13:58.157Z[GMT]")
public class EmissionsForecastDTO {
  @SerializedName("generatedAt")
  private OffsetDateTime generatedAt = null;

  @SerializedName("requestedAt")
  private OffsetDateTime requestedAt = null;

  @SerializedName("location")
  private String location = null;

  @SerializedName("dataStartAt")
  private OffsetDateTime dataStartAt = null;

  @SerializedName("dataEndAt")
  private OffsetDateTime dataEndAt = null;

  @SerializedName("windowSize")
  private Integer windowSize = null;

  @SerializedName("optimalDataPoints")
  private List<EmissionsDataDTO> optimalDataPoints = null;

  @SerializedName("forecastData")
  private List<EmissionsDataDTO> forecastData = null;

  public EmissionsForecastDTO generatedAt(OffsetDateTime generatedAt) {
    this.generatedAt = generatedAt;
    return this;
  }

  /**
   * Timestamp when the forecast was generated.
   *
   * @return generatedAt
   */
  @Schema(example = "2022-06-01T00:00Z", description = "Timestamp when the forecast was generated.")
  public OffsetDateTime getGeneratedAt() {
    return generatedAt;
  }

  public void setGeneratedAt(OffsetDateTime generatedAt) {
    this.generatedAt = generatedAt;
  }

  public EmissionsForecastDTO requestedAt(OffsetDateTime requestedAt) {
    this.requestedAt = requestedAt;
    return this;
  }

  /**
   * For current requests, this value is the timestamp the request for forecast data was made. For
   * historical forecast requests, this value is the timestamp used to access the most recently
   * generated forecast as of that time.
   *
   * @return requestedAt
   */
  @Schema(
      example = "2022-06-01T00:03:30Z",
      description =
          "For current requests, this value is the timestamp the request for forecast data was made.  For historical forecast requests, this value is the timestamp used to access the most   recently generated forecast as of that time.")
  public OffsetDateTime getRequestedAt() {
    return requestedAt;
  }

  public void setRequestedAt(OffsetDateTime requestedAt) {
    this.requestedAt = requestedAt;
  }

  public EmissionsForecastDTO location(String location) {
    this.location = location;
    return this;
  }

  /**
   * The location of the forecast
   *
   * @return location
   */
  @Schema(example = "eastus", description = "The location of the forecast")
  public String getLocation() {
    return location;
  }

  public void setLocation(String location) {
    this.location = location;
  }

  public EmissionsForecastDTO dataStartAt(OffsetDateTime dataStartAt) {
    this.dataStartAt = dataStartAt;
    return this;
  }

  /**
   * Start time boundary of forecasted data points. Ignores forecast data points before this time.
   * Defaults to the earliest time in the forecast data.
   *
   * @return dataStartAt
   */
  @Schema(
      example = "2022-06-01T12:00Z",
      description =
          "Start time boundary of forecasted data points. Ignores forecast data points before this time.  Defaults to the earliest time in the forecast data.")
  public OffsetDateTime getDataStartAt() {
    return dataStartAt;
  }

  public void setDataStartAt(OffsetDateTime dataStartAt) {
    this.dataStartAt = dataStartAt;
  }

  public EmissionsForecastDTO dataEndAt(OffsetDateTime dataEndAt) {
    this.dataEndAt = dataEndAt;
    return this;
  }

  /**
   * End time boundary of forecasted data points. Ignores forecast data points after this time.
   * Defaults to the latest time in the forecast data.
   *
   * @return dataEndAt
   */
  @Schema(
      example = "2022-06-01T18:00Z",
      description =
          "End time boundary of forecasted data points. Ignores forecast data points after this time.  Defaults to the latest time in the forecast data.")
  public OffsetDateTime getDataEndAt() {
    return dataEndAt;
  }

  public void setDataEndAt(OffsetDateTime dataEndAt) {
    this.dataEndAt = dataEndAt;
  }

  public EmissionsForecastDTO windowSize(Integer windowSize) {
    this.windowSize = windowSize;
    return this;
  }

  /**
   * The estimated duration (in minutes) of the workload. Defaults to the duration of a single
   * forecast data point.
   *
   * @return windowSize
   */
  @Schema(
      example = "30",
      description =
          "The estimated duration (in minutes) of the workload.  Defaults to the duration of a single forecast data point.")
  public Integer getWindowSize() {
    return windowSize;
  }

  public void setWindowSize(Integer windowSize) {
    this.windowSize = windowSize;
  }

  public EmissionsForecastDTO optimalDataPoints(List<EmissionsDataDTO> optimalDataPoints) {
    this.optimalDataPoints = optimalDataPoints;
    return this;
  }

  public EmissionsForecastDTO addOptimalDataPointsItem(EmissionsDataDTO optimalDataPointsItem) {
    if (this.optimalDataPoints == null) {
      this.optimalDataPoints = new ArrayList<EmissionsDataDTO>();
    }
    this.optimalDataPoints.add(optimalDataPointsItem);
    return this;
  }

  /**
   * The optimal forecasted data point within the &#x27;forecastData&#x27; array. Null if
   * &#x27;forecastData&#x27; array is empty.
   *
   * @return optimalDataPoints
   */
  @Schema(
      example =
          "{\"location\":\"eastus\",\"timestamp\":\"2022-06-01T14:45:00Z\",\"duration\":30,\"value\":359.23}",
      description =
          "The optimal forecasted data point within the 'forecastData' array.  Null if 'forecastData' array is empty.")
  public List<EmissionsDataDTO> getOptimalDataPoints() {
    return optimalDataPoints;
  }

  public void setOptimalDataPoints(List<EmissionsDataDTO> optimalDataPoints) {
    this.optimalDataPoints = optimalDataPoints;
  }

  public EmissionsForecastDTO forecastData(List<EmissionsDataDTO> forecastData) {
    this.forecastData = forecastData;
    return this;
  }

  public EmissionsForecastDTO addForecastDataItem(EmissionsDataDTO forecastDataItem) {
    if (this.forecastData == null) {
      this.forecastData = new ArrayList<EmissionsDataDTO>();
    }
    this.forecastData.add(forecastDataItem);
    return this;
  }

  /**
   * The forecasted data points transformed and filtered to reflect the specified time and window
   * parameters. Points are ordered chronologically; Empty array if all data points were filtered
   * out. E.G. dataStartAt and dataEndAt times outside the forecast period; windowSize greater than
   * total duration of forecast data;
   *
   * @return forecastData
   */
  @Schema(
      example =
          "[{\"location\":\"eastus\",\"timestamp\":\"2022-06-01T14:40:00Z\",\"duration\":30,\"value\":380.99},{\"location\":\"eastus\",\"timestamp\":\"2022-06-01T14:45:00Z\",\"duration\":30,\"value\":359.23},{\"location\":\"eastus\",\"timestamp\":\"2022-06-01T14:50:00Z\",\"duration\":30,\"value\":375.12}]",
      description =
          "The forecasted data points transformed and filtered to reflect the specified time and window parameters.  Points are ordered chronologically; Empty array if all data points were filtered out.  E.G. dataStartAt and dataEndAt times outside the forecast period; windowSize greater than total duration of forecast data;")
  public List<EmissionsDataDTO> getForecastData() {
    return forecastData;
  }

  public void setForecastData(List<EmissionsDataDTO> forecastData) {
    this.forecastData = forecastData;
  }

  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    EmissionsForecastDTO emissionsForecastDTO = (EmissionsForecastDTO) o;
    return Objects.equals(this.generatedAt, emissionsForecastDTO.generatedAt)
        && Objects.equals(this.requestedAt, emissionsForecastDTO.requestedAt)
        && Objects.equals(this.location, emissionsForecastDTO.location)
        && Objects.equals(this.dataStartAt, emissionsForecastDTO.dataStartAt)
        && Objects.equals(this.dataEndAt, emissionsForecastDTO.dataEndAt)
        && Objects.equals(this.windowSize, emissionsForecastDTO.windowSize)
        && Objects.equals(this.optimalDataPoints, emissionsForecastDTO.optimalDataPoints)
        && Objects.equals(this.forecastData, emissionsForecastDTO.forecastData);
  }

  @Override
  public int hashCode() {
    return Objects.hash(
        generatedAt,
        requestedAt,
        location,
        dataStartAt,
        dataEndAt,
        windowSize,
        optimalDataPoints,
        forecastData);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class EmissionsForecastDTO {\n");

    sb.append("    generatedAt: ").append(toIndentedString(generatedAt)).append("\n");
    sb.append("    requestedAt: ").append(toIndentedString(requestedAt)).append("\n");
    sb.append("    location: ").append(toIndentedString(location)).append("\n");
    sb.append("    dataStartAt: ").append(toIndentedString(dataStartAt)).append("\n");
    sb.append("    dataEndAt: ").append(toIndentedString(dataEndAt)).append("\n");
    sb.append("    windowSize: ").append(toIndentedString(windowSize)).append("\n");
    sb.append("    optimalDataPoints: ").append(toIndentedString(optimalDataPoints)).append("\n");
    sb.append("    forecastData: ").append(toIndentedString(forecastData)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }
}
